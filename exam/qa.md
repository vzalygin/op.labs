# Вопросы к экзамену и ответы на них

## 1. Синтаксис и семантика языков программирования. Алфавит языка Pascal. Описание синтаксиса языка: синтаксические диаграммы. Примеры

### Синтаксис и семантика

Синтаксис: "Как пишется"
Семантика: "Что значит"

Синтаксис - правила, определяющие допустимые конструкции языка. «Защищенный» синтаксис предполагает, что предложения языка строятся по правилам, которые позволяют автоматически выявлять большой процент ошибок в программах.

Семантика – правила, определяющие смысл синтаксически корректных предложений. Ясная или «интуитивно-понятная» семантика – семантика, позволяющая без большого труда определять смысл программы или «читать» ее.

### Общая идея

Все программы содержат раздел описаний и раздел операторов. В блоке описаний можно объявлять переменные (иногда инициализировать), собственные типы, прототипы функций/процедур. В блоке операторов содержатся операторы (как неожиданно), операторы разделяются `;` (в отличие от си-подобных языков, где `;` означает конец выражения). Программа разделяется на основную подпрограмму и остальные подпрограммы (функции, процедуры).

### Алфавит

* латинские буквы без различия регистра
* арабские цифры
* шестнадцатеричные цифры: 0..9, a..f
* специальные символы: `+ - * / = := ;` и т.д.
* служебные слова: `while for, do, begin, end` и т.д.

## Синтаксические диаграммы

![Слайд с первой презы](diagrams.png)

## 2. Представление данных в языке Pascal: константы и переменные. Классификация скалярных типов данных, их внутреннее представление, операции над ними. Примеры

Константы - неизменяемые данные.
Литералы - константы, указанные непоследственно в программе (`-25, $2a, true, 'd', #65, 'foo', nil`)

```pascal
//константа
const {name} = {value};

// переменная
var {name}: {type};
```

![Слайд с первой презы](types.png)

Целые:

* integer 4 байта
* smallint 2 байта
* shortint 1 байт
* word 2 байта без знака
* byte догадайтесь сами

Вещественные:

* real/double 8 байт
* single 4 байт
* extended 10 байт
* comp 8 байт

Устройство вещественных чисел: знаковый бит + порядок (характеристика) + мантисса

Также есть:

* boolean 1 байт (связано с тем, что минимальное адресуемая единица - 1 байт)
* widechar 2 байта (таблица unicode)
* Перечисление. Описываются всевозможные варианты значения

```pascal
type whoami = (Cat, Human, Clock);
var he: (Cat, Human, Clock)/whoami;
he := Human;
```

* Отрезки

```pascal
type months = 1..12;
```

### Доступные операции

`:=, +, -, / (вещественно), div (целочисленно), mod, <, <=, <>, =, and, or, xor, not, shr, shl`

```pascal
Ord - предыдущее значение
Pred - значение, уменьшеное на 1 (для целочисленных эти функции эквиваленты)
Succ - следующее значение
Inc - значение, увеличенное на 1
High - самое большое значение типа
Low - самое малое значение типа
```

## 3. Совместимость типов данных и операции преобразования типов. Примеры

При операциях приисходит неявное приведение типов по следующей схеме:

* При арифметике целого и вещственного - оба преобразуются к вещественную
* При с разными интервалами представлений - к большему интервалу.
* При сравнении вещественных типов рекомендуется указывать допуск:

```pascal
abs(x-y) < eps
```

В случае переполнения при арифметической операции происходит переход в начало интервала типа. Или при включённом флаге происходит паника.

Для явного преобразования существуют функции

```pascal
trunc(real): integer // отрезает дробную часть
round(real): integer // округляет по правилам арифметики
ord(type): integer // возвращает номер значения в типе
chr(integer): char // возвращает символ с номером
```

## 4. Присваивание, условный оператор, оператор выбора. Синтаксис операторов, их особенности и примеры использования.

Представление в паскале:

```pascal
// Оператор присваивания
foo := bar;

// Условный оператор
if {exp} then
{code}
else if {exp} then
{code}
else
{code}

// Оператор выбора
case {exp} of
  {exp}: {code};
  {exp}: {code};
  else {code};
end;    

case 1+2*j of
  3:  Write('1');
  -1..1, 10: Write('2');
  else: Write('3');
end;
```

### Особенности

Ветвь `else` относится к ближайшему `if`

## 5. Операторы циклов языка Pascal. Синтаксис операторов, их особенности и примеры использования

Типы циклов:

* Счётные - `for` (известно кол-во повторений)
* Итерационные - `while, repeat until` (пока выполняется какое-то условие)
* Поисковые (нашли и перебрали всё и не нашли, _какое `и` к чему относится - вопрос открытый_)

Представление в паскале:

```pascal
while {exp} do
  {code}

repeat
  {code}
until {exp} // пока выражение ложно

for {var} := {start} to/downto {end} do
  {code}
```

## 6. Поисковый цикл. Неструктурная и структурная реализации поискового цикла

Структурная реализация отличается от неструктурной тем, что использует только структурные операторы (`break` таком вы не является). Для структурной реализации используют флаг, который сигнализирует о наличии требуемого элемента.

```pascal
// Структурный
found := false;
i := 0;
while (i < High(arr)) and (not found) do begin
  if arr[i] > 5 then begin
    write(arr[i]);
    found := true;
  end;
  i += 1;
end;

// Неструктурный
i := 1;
while i < High(arr) do begin
  if arr[i] > 5 then begin
    write(arr[i]);
    break; // плохо
  end;
  i += 1;
end;
```

## 7. Массивы языка Pascal. Описание, внутреннее представление, операции над массивами и их элементами. Примеры

Упорядоченная совокупность однотипных данных. каждому элементу массива соответствует один или несколько индексов порядкового типа, определяющих положение элемента в массиве.

Кол-во типов индексов опеределяет **размерность массива**.
Пример: двумерный массив, одномерных массив и т.д.

* Тип индекса - порядковый - определяет доступ к элементу
* Тип элемента - любой кроме файла.

Массив в памяти не может занимать больше 2гб. Могу предположить, что это связано с тем, что указатели имеют размер в 4 байта, соотвественно могут иметь 2^^32 значений, а это 2гб. Искать информацию по этому поводу мне лень.

```pascal
type foo = array[ord_type] of type;

type bar = array[1..64] of integer;
var baz: bar; 
```

Внутренне массив представляется как последовательность ячеек. Каждая ячейка имеет свой индекс, по которому к ней можно обратиться.

Операции над массивами:

```pascal
// Чтение из ячейки
// Прямой доступ
bar := arr[5]
// Косвенный доступ (от переменной, а не литерала)
bar := arr[foo]

// Запись в ячейку
arr[foo] := bar;
```

Также возможно, что Иванова под операциями над массивами подразумевает последовательную обработку его элементов с какой-то целью, например, для вывода на экран.

## 8. Строки языка Pascal. Описание, внутреннее представление, операции над строками и их элементами. Примеры

Строка - последоватльность символом

```pascal
foo: string[{max_length}]
bar: string[{max_length}] = '{value}';
```

Внутреннее представляется как массив байтов, где в первом элементе хранится текущая длина строки (<= максимальной), а в последуюших сами символы строки.

**Максимальная длина строки - 255**, т.к. первый байт, отвечающий за длину, может принимать значения от 0 до 255.

Операции над строками:

```pascal
foo, bar: string[40]

foo := bar // Присваивание
foo := '';

foo := foo + bar // Конкантенация

foo > bar // Попарное сравнение соответствующих элементов, результат определяется первым неравным сравнением.

// Без комментариев
Length(foo)
Delete(foo, index, count)
Insert(foo, bar. count)
Copy(foo, index, count): string

Pos(foo, bar): integer // индекс первого вхождения строки bar в foo. Если вхождений нет, то 0.
UpCase(char): char // Соответствующий символ верхнего регистра.
Str({integer}[:w[:d]], foo) // из числа в строку (передаётся ссылкой)
Val(foo, integer, code) // из строки в число. При успешном переводе code имеет значение 0, в противном случае - другое.

```

9. Множества языка Pascal. Описание, внутреннее представление, операции над множе-
ствами и их элементами. Примеры.
10. Записи языка Pascal. Описание, внутреннее представление, операции над записями и их
элементами. Примеры.
11. Процедуры и функции. Определение, описание, особенности. Примеры.
12. Способы передачи данных в подпрограмму на языке Pascal. Примеры.
13. Локальные и глобальные переменные, законы «видимости» идентификаторов. Примеры.
14. Формальные и фактические параметры подпрограмм языка Pascal. Примеры.
15. Параметры-строки, параметры-массивы. Примеры.
16. Принципы разработки универсальных подпрограмм: «открытые» массивы. Примеры.
17. Принципы разработки универсальных подпрограмм: нетипизированные параметры, па-
раметры процедурного типа. Примеры.
18. Структура модуля языка Pascal. Законы видимости идентификаторов. Доступ к «пере-
крытым» идентификаторам. Примеры.
19. Рекурсия. Виды рекурсии. Особенности программирования. Достоинства и недостатки.
Пример.
20. Адресация динамической памяти: понятие адреса, операции получения адреса и разыме-
нования. Процедуры получения памяти и освобождения ее. Примеры.
21. Списковые структуры данных. Классификация и основные приемы работы с ними: соз-
дание элемента, добавление элемента к списку, удаление элемента из списка. Область приме-
нения списковых структур данных. Пример.
22. Основы файловой системы: файл, каталог, полное имя файла, внутреннее представление
информации в файле. Файловая переменная. Операции открытия и закрытия файлов. Приме-
ры.
2
23. Текстовые файлы. Внутреннее представление информации в файле. Операции над фай-
лами. Пример.
24. Типизированные файлы: внутреннее представление информации в файле. Операции над
файлами. Пример.
25. Нетипизированные файлы. Внутреннее представление информации в файле. Операции
над файлами. Пример.
26. Классы консольного режима среды Lazarus: описание классов, поля и методы, объявление
объектов класса, доступ к полям и методам объекта, ограничение доступа. Пример.
27. Классы консольного режима среды Lazarus: Способы инициализация полей. Неявный па-
раметр Self. Пример.
28. Процедурная и объектная декомпозиция. Диаграммы классов. Отношения между класса-
ми. Примеры.
29. Динамические объекты и объекты с динамическими полями в консольном режиме среды
Lazarus. Примеры.
30. Технология событийного программирования. События операционной системы, сообще-
ния и события Lazarus. Основные события Lazarus. Примеры