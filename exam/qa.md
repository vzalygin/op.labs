# Вопросы к экзамену и ответы на них

## 1. Синтаксис и семантика языков программирования. Алфавит языка Pascal. Описание синтаксиса языка: синтаксические диаграммы. Примеры

### Синтаксис и семантика

Синтаксис: "Как пишется"
Семантика: "Что значит"

Синтаксис - правила, определяющие допустимые конструкции языка. «Защищенный» синтаксис предполагает, что предложения языка строятся по правилам, которые позволяют автоматически выявлять большой процент ошибок в программах.

Семантика – правила, определяющие смысл синтаксически корректных предложений. Ясная или «интуитивно-понятная» семантика – семантика, позволяющая без большого труда определять смысл программы или «читать» ее.

### Общая идея

Все программы содержат раздел описаний и раздел операторов. В блоке описаний можно объявлять переменные (иногда инициализировать), собственные типы, прототипы функций/процедур. В блоке операторов содержатся операторы (как неожиданно), операторы разделяются `;` (в отличие от си-подобных языков, где `;` означает конец выражения). Программа разделяется на основную программу (точка входа) и подпрограммы (остальные части программы).

### Алфавит

- латинские буквы без различия регистра
- арабские цифры
- шестнадцатеричные цифры: 0..9, a..f
- специальные символы: `+ - * / = := ;` и т.д.
- служебные слова: `while, for, do, begin, end` и т.д.

## Синтаксические диаграммы

![Слайд с первой презы](diagrams.png)

## 2. Представление данных в языке Pascal: константы и переменные. Классификация скалярных типов данных, их внутреннее представление, операции над ними. Примеры

Константы - неизменяемые данные.
Литералы - константы, указанные непоследственно в программе (`-25, $2a, true, 'd', #65, 'foo', nil`)

```pascal
//константа
const {name} = {value};

// переменная
var {name}: {type};
```

![Слайд с первой презы](types.png)

Целые:

- integer 4 байта
- smallint 2 байта
- shortint 1 байт
- word 2 байта без знака
- byte догадайтесь сами

Вещественные:

- real/double 8 байт
- single 4 байт
- extended 10 байт
- comp 8 байт

Устройство вещественных чисел: знаковый бит + порядок (характеристика) + мантисса

Также есть:

- boolean 1 байт (связано с тем, что минимальное адресуемая единица - 1 байт)
- widechar 2 байта (таблица unicode)
- Перечисление. Описываются всевозможные варианты значения

```pascal
type whoami = (Cat, Human, Clock);
var he: (Cat, Human, Clock)/whoami;
he := Human;
```

- Отрезки

```pascal
type months = 1..12;
```

### Доступные операции

`:=, +, -, / (вещественно), div (целочисленно), mod, <, <=, <>, =, and, or, xor, not, shr, shl`

```pascal
Ord - предыдущее значение
Pred - значение, уменьшеное на 1 (для целочисленных эти функции эквиваленты)
Succ - следующее значение
Inc - значение, увеличенное на 1
High - самое большое значение типа
Low - самое малое значение типа
```

## 3. Совместимость типов данных и операции преобразования типов. Примеры

При операциях приисходит неявное приведение типов по следующей схеме:

- При арифметике целого и вещственного - оба преобразуются к вещественную
- При арифметике с разными интервалами представлений - к большему интервалу.
- При сравнении вещественных типов рекомендуется указывать допуск:

```pascal
abs(x-y) < eps
```

В случае переполнения при арифметической операции происходит переход в начало интервала типа. Или при включённом флаге происходит паника.

Для явного преобразования существуют функции

```pascal
trunc(real): integer // отрезает дробную часть
round(real): integer // округляет по правилам арифметики
ord(type): integer // возвращает номер значения в типе
chr(integer): char // возвращает символ с номером
```

## 4. Присваивание, условный оператор, оператор выбора. Синтаксис операторов, их особенности и примеры использования.

Представление в паскале:

```pascal
// Оператор присваивания
foo := bar;

// Условный оператор
if {exp} then
{code}
else if {exp} then
{code}
else
{code}

// Оператор выбора
case {exp} of
  {exp}: {code};
  {exp}: {code};
  else {code};
end;

case 1+2*j of
  3:  Write('1');
  -1..1, 10: Write('2');
  else: Write('3');
end;
```

### Особенности

Ветвь `else` относится к ближайшему `if`

## 5. Операторы циклов языка Pascal. Синтаксис операторов, их особенности и примеры использования

Типы циклов:

- Счётные - `for` (известно кол-во повторений)
- Итерационные - `while, repeat until` (пока выполняется какое-то условие)
- Поисковые (нашли или перебрали всё и не нашли)

Представление в паскале:

```pascal
while {exp} do
  {code}

repeat
  {code}
until {exp} // пока выражение ложно

for {var} := {start} to/downto {end} do
  {code}
```

## 6. Поисковый цикл. Неструктурная и структурная реализации поискового цикла

Структурная реализация отличается от неструктурной тем, что использует только структурные операторы (`break` таковым не является). Для структурной реализации используют флаг, который сигнализирует о наличии требуемого элемента.

```pascal
// Структурный
found := false;
i := 0;
while (i < High(arr)) and (not found) do begin
  if arr[i] > 5 then begin
    write(arr[i]);
    found := true;
  end;
  i += 1;
end;

// Неструктурный
i := 1;
while i < High(arr) do begin
  if arr[i] > 5 then begin
    write(arr[i]);
    break; // плохо
  end;
  i += 1;
end;
```

## 7. Массивы языка Pascal. Описание, внутреннее представление, операции над массивами и их элементами. Примеры

Упорядоченная совокупность однотипных данных. каждому элементу массива соответствует один или несколько индексов порядкового типа, определяющих положение элемента в массиве.

Кол-во типов индексов опеределяет **размерность массива**.
Пример: двумерный массив, одномерных массив и т.д.

- Тип индекса - порядковый - определяет доступ к элементу
- Тип элемента - любой кроме файла.

Массив в памяти не может занимать больше 2гб. (TODO: разобраться почему)

```pascal
type foo = array[ord_type] of type;

type bar = array[1..64] of integer;
var baz: bar;
```

Внутренне массив представляется как упорядоченная последовательность ячеек. Каждая ячейка имеет свой индекс, по которому к ней можно обратиться.

Операции над массивами:

```pascal
// Чтение из ячейки
// Прямой доступ
bar := arr[5]
// Косвенный доступ (от переменной, а не литерала)
bar := arr[foo]

// Запись в ячейку
arr[foo] := bar;
```

Также возможно, что Иванова под операциями над массивами подразумевает последовательную обработку его элементов с какой-то целью, например, для вывода на экран.

## 8. Строки языка Pascal. Описание, внутреннее представление, операции над строками и их элементами. Примеры

Строка - последоватльность символом

```pascal
foo: string[{max_length}]
bar: string[{max_length}] = '{value}';
```

Внутреннее представляется как массив байтов, где в первом элементе хранится текущая длина строки (<= максимальной), а в последуюших сами символы строки.

**Максимальная длина строки - 255**, т.к. первый байт, отвечающий за длину, может принимать значения от 0 до 255.

Операции над строками:

```pascal
foo, bar: string[40]

foo := bar // Присваивание
foo := '';

foo := foo + bar // Конкантенация

foo > bar // Попарное сравнение соответствующих элементов, результат определяется первым неравным сравнением.

// Без комментариев
Length(foo)
Delete(foo, index, count)
Insert(foo, bar. count)
Copy(foo, index, count): string

Pos(foo, bar): integer // индекс первого вхождения строки bar в foo. Если вхождений нет, то 0.
UpCase(char): char // Соответствующий символ верхнего регистра.
Str({integer}[:w[:d]], foo) // из числа в строку (передаётся ссылкой)
Val(foo, integer, code) // из строки в число. При успешном переводе code имеет значение 0, в противном случае - другое.

```

## 9. Множества языка Pascal. Описание, внутреннее представление, операции над множествами и их элементами. Примеры

Множество - неупорядоченная сокупность неповторяющихся данных.
**Максимальная длина - 256**

```pascal
type s1 = set of char
type s2 = set of 1..100;
```

```pascal
// Конструкторы для множества
[] // пустое множество
[2, 3, 5, 6, 11] // множество чисел
['a', 'b', 'e', 't'] // множество символом
[1, k] // множество чисел 1 и k
[2..100] // множество значений от 2 до 100
[k..2*k] // можно задать выражением
[red, yellow, green] // множество перечисляемого типа
```

```pascal
// Операции над множествами
a = []
b = []
a + b // объединение
a * b // пересечение
a - b // дополнение множества b до a (или a до b, у Ивановой так написано. Хотя я сам думаю, что правилен первый вариант)
a = b
a <> b
a <= b // нестрогое вхождение a в b
a > b // сторогое
```

В памяти множество представляется как последовательность ячеек, хрянящих булево значение. Каждая ячейка хранит наличие или отсутствие элемента в множестве.

## 10. Записи языка Pascal. Описание, внутреннее представление, операции над записями и их элементами. Примеры

Структура данных, образованная _фиксированным_ числом разнотипных компонентов. Элементы внутри записи называются полями.

```pascal
type employee = record
  id: integer;
  name: string;
  last_name: string;
  phone: string[11];
end;

var petr: employee;

petr.name := 'petr'; // точечная нотация
with petr do last_name := 'vasilyev'; // через оператор доступа

```

В памяти представляется как блок памяти, где последовательно хранятся значения каждого поля записи. (Адрес поля можно получить, прибавив к адресу начала записи размер полей, идущих до требуемого поля.)

## 11. Процедуры и функции. Определение, описание, особенности. Примеры

> Самостоятельные фрагменты программы, вызываемые по имени.

Можно попробовать дать определение по признакам.  
Функция/процедура:

- Имеет имя
- Имеет >= 0 параметров
- Исполняет код, зависящий от параметров
- Может возвращать результат (в случае функции)

_Предполагается, что функции/процедуры не используют глобальную память и используют свои агрументы по назначению._

```pascal
// Синтаксис объявления процедур
procedure foo(a: integer);

// Синтакис объявления функций
function bar(b: integer): real;
// Скобки можно опускать, если нет параметров
function baz: real;
```

**Процедуры в отличие от функций не могут возвращать значения.**

## 12. Способы передачи данных в подпрограмму на языке Pascal. Примеры

Есть два ~~стула~~ способа:

- Через глобальные переменные (неявно)
- Через параметры (явно)

**Строго рекомендуется использовать только второй способ, т.к. это жестко связывает подпрограмму и данные и приводит к большому количеству ошибок (самостоятельно ответьте на вопрос `почему так происходит`).**

Здесь ещё можно привести пример, демонстрирующих оба способа передачи, достоинства и их недостатки и т.д., но мне лень :/

## 13. Локальные и глобальные переменные, законы «видимости» идентификаторов. Примеры

Глобальные и локальные переменные отличаются в нескольких отношениях.
| Признак | Глобальные | Локальные |
|---------|------------|-----------|
|Где объявляются|В основной программе|В подпрограммах|
|Время жизни|От старта работы до завершения - всё время работы программы|От вызова подпрограммы до возврата управления - время работы подпрограммы|
|Доступность|Из любого места, включая подпрограммы*|Из подпрограммы и подпрограмм, вызываемых из неё*|

\*при отсуствии перекрытия имён

> Если имя локальной переменной совпадает с именем глобальной, то локальная переменная "перекрывает" глобальную, которая в свою очередь становится недоступна.

## Формальные и фактические параметры подпрограмм языка Pascal. Примеры

- Формальные - те, которые пишутся в заголовке функций/процедур
- Фактические - те, которые передаются в подпрограмму непосредственно при вызове.

Параметры можно передавать по значению и по ссылке. В случае передачи по значению, значение переменной копируются. При передачи по ссылке работа идёт с переменными из вызывающей программы, соответственно все изменения переменных также отражаются в вызывающей программе.

При передаче по _изменяемой_ ссылке нельзя передавать литералы.

При передаче по неизменяемой ссылке параметр всё равно ссылается на переменную из вызывающей программы, но вызываемая программа не может её менять.

```pascal
// По значению
procedure foo(bar: integer);

// По изменяемой ссылке
procedure foo(var bar: integer);

// По неизменяемой ссылке
procedure foo(const bar: integer);
```

## 15. Параметры-строки, параметры-массивы. Примеры

При передаче структурных параметров (массивы, множества, строки, записи, указатели, файлы) их типы должны быть объявлены заранее.

```pascal
function foo(bar: ^integer): ^integer; // ошибка

type int_ptr = ^integer;
function foo(bar: int_ptr): int_ptr; // правильно
```

_Хотя компилятор будет ругаться только на тип возвращаемого значения..._

## 16. Принципы разработки универсальных подпрограмм: «открытые» массивы. Примеры

Конструкция объявления массива без указания типа индекса. **Используется при объявлении формальных параметров.** Наряду с стандартным использованием открытые массивы также можно использовать для объявления динамических массивов, память под которые выделяется во время выполнения процедуры `SetLength`.

**Индексы открытых массивов всегда начинаются с нуля.**
Также к открытым массивам применимы функции `High` и `Low`, которые возвращают индексы последнего и первого элементов соответственно.

Используются для повышения универсальности подпрограмм, которые непривязаны к длине передаваемых массивов.

```pascal
function foo(bar: array of integer): integer;
```

## 17. Принципы разработки универсальных подпрограмм: нетипизированные параметры, параметры процедурного типа. Примеры

### Нетепизированные параметры - ссылочные параметры без типа

```pascal
procedure foo(var bar);
```

Для работы с такими параметрами необходимо привести их определённому виду. Есть несколько способов:

```pascal
// Автоопределённое преобразование типов
procedure foo(var bar);
...
  b := Integer(bar) + 10;
...

// Наложенное описание переменной определённого типа
procedure foo(var bar);
var baz: integer absolute bar;
```

Фактически на область памяти, на которую ссылается нетипизированный параметр, накладывается разрядная сетка типа, к которому приводят параметр, надеясь, что получится нечто вразумительное.

Такую особенность можно использовать для написания некоторых вещей:

- Универсальные подпрограммы над разными типами
- Универсальные подпрограммы над многомерными массивами.

Подпрограммы, работающие с многомерными массивами, используют тот факт, что строки, столбцы и другие направления в них располагаются сторого упорядоченно в одну полоску данных. Для двумерного массива: строки идут попорядку друг за другом:

![Развёртка открытого массива](./open_arrays.png)

### Параметры процедурного типа

Всё очень просто, функции/процедуры в паскале являются [объектами первого класса](https://ru.wikipedia.org/wiki/%D0%9E%D0%B1%D1%8A%D0%B5%D0%BA%D1%82_%D0%BF%D0%B5%D1%80%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%B0). Соотвественно для их использования в качестве объектов первого класса нужно сделать следующее:

1. В файле написать флаг компиляции для free pascal (переключить его в режим Delphi), т.к. без него он не умеет в передачу процедурных типов.

2. Объявить процедурный тип:

```pascal
type func = function(bar: integer): integer;
```

3. Использовать его:

```pascal
procedure foo(baz: func);
```

## 18. Структура модуля языка Pascal. Законы видимости идентификаторов. Доступ к «перекрытым» идентификаторам. Примеры

Модуль - автономно компилируемая коллекция программных ресурсов, предназначенных для использования другими модулями.

Ресурсы - переменные, константы, описания типов и подпрограммы.

1. Внешние - предназначены для использования другими программами и модулями
2. Внутренние - предназначены для использования внутри модуля

```pascal
// Структура модуля
unit {name};
interface
{секция объявлений}
implementation
{секция реализация}
initialization
{секция инициализаций}
finalization
{секция завершения}
end.
```

```pascal
// Подключение модулей
uses foo in '../foo.pas'; // Можно указать относительный или абсолютный путь
```

Использование указания in … в файлах с расширением pas не допустимо. (TODO: разобраться почему)

**Ресурсы модуля перекрываются ресурсами программы и ранее указанных модулей.**

Для доступа к перекрытым идентификаторам можно использовать оператор `.`

```pascal
uses foo in '../foo.pas';

procedure bar;

foo.bar() // можно обратиться к перекрытому ресурсу
```

## 19. Рекурсия. Виды рекурсии. Особенности программирования. Достоинства и недостатки. Пример

Организация вычислений, при которой процедура или функция вызывает саму себя.

- Явная рекурсия - функция вызывает сама себя
- Косвенная рекурсия - функция вызывает другую функцию, которая вызывает исходную.

Для косвенной рекурсии нужно использовать слово `forward`.

```pascal
procedure foo; forward;

procedure bar;
begin
  foo
end;

procedure foo;
begin
  bar
end;
```

Базис функции - случай, когда функция перестаёт рекурсивно себя вызывать:

```pascal
function fac(n: integer): integer
begin
  if n > 1 then
    Result := n * fac(n-1)
  else
    Result := n // базис рекурсии
end;
```

При каждом вызове функции на стек добавляется её фрейм активации, который включает:

- локальные переменные
- копии параметров-значений
- адреса параметров-переменных и параметров-констант (4 байта)
- копию строки результата (для функция типа `string`)
- служебную информацию (~12 байт)

При этом, по словам Ивановой, компилятор паскаля _не умеет_ оптимизировать хвостовую рекурсию, из-за чего любой рекурсивный алгоритм имеет оверхед по потребляемой памяти, по сравнению с циклическими аналогами.

Также различают линейную и древовидную рекурсию. При древовидной рекурсии функция вызывает саму себя несколько раз, когда при линейной - один. В качестве примера можно рассмотреть алгоритм вычисления всех возможных перестановок.

Достоинства:

- Древовидная рекурсия позволяет писать алгоритмы, которые при циклах были бы очень сложны
- Мне лично удобно писать обработчики рекурсивных структур данных с помощью рекурсии. Будь то связный список или дерево.

Недостатки:

- Оверхед по потреблению памяти из-за стоимости каждого вызова и отсутствию оптимизации хвостовой рекурсии.
- ~~зумеры слишком тупые, чтобы освоить рекурсию~~ Трудность отладки и в целом построения рекурсивных алгоритмов.

## 20. Адресация динамической памяти: понятие адреса, операции получения адреса и разыменования. Процедуры получения памяти и освобождения ее. Примеры

Память компьютера состоит из упорядоченного набора минимальных адресуемых единиц (в основном байт). Байты нумеруют, начиная с 0. _Вопрос на засыпку, на определение чего похоже первое предложение?_

Для удобства абсолютный адрес данных разделяют на базу и смещение. База - какой-то общий адрес, смещение - сдвиг вперёд относительно базы.

Адресация по схеме "базис + смещение" обеспечивает "перемещаемость" программ в оперативной памяти, т.е. загрузку в разные места оперативной памяти в зависимости от того, какой участок свободен.

Указатель - 4 байта без знака, которые используют для хранения смещений, может адресовать сегмент размером 2^^32 = 4гб.

Оператор `@` или функция `Addr` возвращают указатель на переменную в памяти.
Оператор `^` используется для разыменовывания указателя (помимо объявления типизированных указателей)

```pascal
bar := 5;
foo := @bar; // foo:  ^integer
baz := foo^; // baz = 5;
```

Процедуры `New({^type})` и `Dispose({^type})` позволяют выделить (количество определяется в соответствии с типом указателя) и освободить память, на которую указывает указатель.

Также существуют процедуры `GetMem({pointer}, {size})` и `FreeMem({pointer}[, {size}])`, которые позволяют выделять память на нетипизированные указатели с явным количеством байт.

**Разыменовывать нетипизированный указатель нельзя. Для разыменовывания его нужно привести к какому-то типу.**

Просто оставлю это здесь:

![Распределение памяти](./memory.png)

## 21. Списковые структуры данных. Классификация и основные приемы работы с ними: создание элемента, добавление элемента к списку, удаление элемента из списка. Область применения списковых структур данных. Пример

Примеры линейных и динамических структур:

- Стек (реализует парадигму LIFO - last in, first out)
- Очередь (реализует парадигму FIFO - first in, first out)
- Дек (~~считайте его панком.~~ Умеет добавлять и удалять элементы с любой стороны)

Такие структуры можно организовать с помощью списков, которые бывают:

- линейные
- кольцевые
- древовидные
- N-связные

Интересно посмотреть на связные списки, которые подобны массивам, но могут иметь произвольное количество элементов, могут добавлять и удалять элементы, не перемещая остальных. Ради таких удобств проходится платить: нет прямого обращения по индексу, требует больше памяти.

Различают односвязаные, двусвязные и n-связные списки. Односвязные - элемент ссылается на следующий после себя, двусвязные - элемент ссылается на следующий и предыдущий, n-связные - элемент ссылается на n-других элементов.

Добавлять элементы в список можно по стеку или по очереди. (см 6 презентацию)

22. Основы файловой системы: файл, каталог, полное имя файла, внутреннее представление информации в файле. Файловая переменная. Операции открытия и закрытия файлов. Примеры.
23. Текстовые файлы. Внутреннее представление информации в файле. Операции над файлами. Пример.
24. Типизированные файлы: внутреннее представление информации в файле. Операции над файлами. Пример.
25. Нетипизированные файлы. Внутреннее представление информации в файле. Операции над файлами. Пример.
26. Классы консольного режима среды Lazarus: описание классов, поля и методы, объявление объектов класса, доступ к полям и методам объекта, ограничение доступа. Пример.
27. Классы консольного режима среды Lazarus: Способы инициализация полей. Неявный параметр Self. Пример.
28. Процедурная и объектная декомпозиция. Диаграммы классов. Отношения между классами. Примеры.
29. Динамические объекты и объекты с динамическими полями в консольном режиме среды Lazarus. Примеры.
30. Технология событийного программирования. События операционной системы, сообщения и события Lazarus. Основные события Lazarus. Примеры
